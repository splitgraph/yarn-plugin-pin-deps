/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-pin-deps",
factory: function (require) {
var plugin=(()=>{var A=Object.create,b=Object.defineProperty;var E=Object.getOwnPropertyDescriptor;var N=Object.getOwnPropertyNames,R=Object.getOwnPropertySymbols,_=Object.getPrototypeOf,H=Object.prototype.hasOwnProperty,z=Object.prototype.propertyIsEnumerable;var T=(t,e,n)=>e in t?b(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n,U=(t,e)=>{for(var n in e||(e={}))H.call(e,n)&&T(t,n,e[n]);if(R)for(var n of R(e))z.call(e,n)&&T(t,n,e[n]);return t};var J=t=>b(t,"__esModule",{value:!0});var w=t=>{if(typeof require!="undefined")return require(t);throw new Error('Dynamic require of "'+t+'" is not supported')};var Y=(t,e)=>{for(var n in e)b(t,n,{get:e[n],enumerable:!0})},q=(t,e,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of N(e))!H.call(t,o)&&o!=="default"&&b(t,o,{get:()=>e[o],enumerable:!(n=E(e,o))||n.enumerable});return t},$=t=>q(J(b(t!=null?A(_(t)):{},"default",t&&t.__esModule&&"default"in t?{get:()=>t.default,enumerable:!0}:{value:t,enumerable:!0})),t);var K={};Y(K,{default:()=>F});var S=$(w("@yarnpkg/cli")),h=$(w("clipanion")),V=$(w("@yarnpkg/cli")),L=$(w("@yarnpkg/fslib")),c=$(w("@yarnpkg/core")),W=$(w("semver")),x=t=>`[32m${t}[0m`,M=t=>`[33m${t}[0m`,j=(t,e)=>{var l,k,d;let{scope:n,name:o,range:s}=t,{highlight:a}=e!=null?e:{},r=p=>p,i={all:typeof a=="function"?a:r,range:(l=a==null?void 0:a.range)!=null?l:r,name:(k=a==null?void 0:a.name)!=null?k:r,scope:(d=a==null?void 0:a.scope)!=null?d:r};return i.all(`${n?`@${i.scope(n)}/`:""}${i.name(o)}:${i.range(s)}`)},D=class extends S.BaseCommand{constructor(){super(...arguments);this.dryRun=h.Option.Boolean("--dry",{description:"Print the changes to stdout but do not apply them to package.json files."});this.onlyDevDependencies=h.Option.Boolean("--only-dev",{description:"Only devDependencies"});this.ignoreDevDependencies=h.Option.Boolean("--ignore-dev",{description:"Ignore devDependencies (default is false, to pin dependencies and devDependencies)."});this.verbose=h.Option.Boolean("--verbose",{description:"Print more information about skipped or already pinned packages"});this.onlyPackages=h.Option.Array("--only",{description:"To _only_ include a specific name:range package (or packages)."});this.alsoIncludePackages=h.Option.Array("--also",{description:"To pin a specific name:range that would otherwise be skipped"});this.onlyWorkspaces=h.Option.Array("--workspace",{description:"To _only_ include a specific workspace (or workspaces)"})}async execute(){this.configuration=await c.Configuration.find(this.context.cwd,(0,V.getPluginConfiguration)());let{project:e}=await c.Project.find(this.configuration,this.context.cwd);this.project=e,this.cache=await c.Cache.find(this.configuration),await this.project.resolveEverything({cache:this.cache,report:new c.ThrowReport}),await c.StreamReport.start({configuration:this.configuration,stdout:this.context.stdout,includeLogs:!0,json:!1},async n=>{this.log=n,this.gatherWorkspaces(),this.createLocatorsByIdentMap(),await this.findPinnableDependencies(),await this.pinDependencies()})}createLocatorsByIdentMap(){let e=new Map;for(let[n,o]of this.project.storedResolutions.entries()){let s=o,r=this.project.storedDescriptors.get(n).identHash,i=e.get(r);i===void 0?e.set(r,new Set([s])):e.set(r,i.add(s))}return this.locatorsByIdent=e,this.locatorsByIdent}gatherWorkspaces(){let e=!this.onlyWorkspaces||this.onlyWorkspaces.length===0;return this.workspaces=e?this.project.workspaces:this.project.workspaces.filter(n=>{var a,r;let o=[n.cwd,n.relativeCwd,(r=(a=n.manifest)==null?void 0:a.name)==null?void 0:r.name].filter(i=>!!i),s=this.onlyWorkspaces.some(i=>o.includes(i));return s?this.log.reportWarning(0,`${x("\u2713")} Including workspace ${n.manifest.name.name} at ${n.cwd}`):this.logVerboseWarning("gatherWorkspaces",`${M("x")} Excluding workspace ${n.manifest.name.name}, no match for ${o.map(i=>`'${i}'`).join(" or ")}`),s}),this.workspaces}async pinDependencies(){this.log.reportJson({type:"info",name:"pinnableDependencies",displayName:"pinnableDependencies",data:this.pinnableJSON});for(let e of this.workspaces){let{manifest:n,cwd:o}=e,s=L.ppath.join(o,c.Manifest.fileName),a=this.pinnableByWorkspaceCwd.get(o),r=0;for(let[l,{version:k}]of a){let d=n.dependencies.get(l),p=n.devDependencies.get(l),g=d!=null?d:p,I=U({},g);if(d&&p&&this.log.reportWarning(0,`Possible package.json conflict between devDependencies and dependencies in ${g.name} at ${s}`),g.range===k)continue;let y=Object.assign(g,{range:k});d?n.dependencies.set(l,y):p&&n.devDependencies.set(l,y),this.log.reportInfo(0,`${x("\u2192")} Pin ${j(I,{highlight:{range:M}})} \u2192 ${j(y,{highlight:{range:x}})} (${s})`),r=r+1}r>0&&(this.dryRun||await e.persistManifest(),this.log.reportInfo(0,`${x("\u2713")} Pinned ${r} and ${this.dryRun?"saved[DRY RUN]":"saved"} to ${s}`))}}static referencesPackage(e,{scope:n,name:o,range:s}){let a=j({scope:n,name:o,range:s}),r=e===a,i=[`:${s}`,`*:${s}`].includes(e);return r||i}isDependencyExplicitlyIncluded({scope:e,name:n,range:o}){var r,i;let s=((r=this.alsoIncludePackages)!=null?r:[]).some(l=>D.referencesPackage(l,{scope:e,name:n,range:o})),a=((i=this.onlyPackages)!=null?i:[]).some(l=>D.referencesPackage(l,{scope:e,name:n,range:o}));return s||a}logVerboseWarning(e,n){if(!!this.verbose)return this.log.reportWarning(e,n)}logVerboseInfo(e,n){if(!!this.verbose)return this.log.reportInfo(e,n)}async findPinnableDependencies(){this.pinnableByWorkspaceCwd=new Map,this.reportablePinsByWorkspaceCwd=new Map;for(let{manifest:{dependencies:e,devDependencies:n},cwd:o}of this.workspaces){let s=new Map;this.pinnableByWorkspaceCwd.set(o,s);let a=new Map;if(this.reportablePinsByWorkspaceCwd.set(o,a),!this.onlyDevDependencies)for(let[r,i]of e)this.processDependency([r,i],{workspaceCwd:o,pinnableInWorkspace:s,reportablePinsInWorkspace:a,isDevDependency:!1});if(this.onlyDevDependencies||!this.ignoreDevDependencies)for(let[r,i]of n)this.processDependency([r,i],{workspaceCwd:o,pinnableInWorkspace:s,reportablePinsInWorkspace:a,isDevDependency:!0})}}processDependency([e,n],o){let{workspaceCwd:s,pinnableInWorkspace:a,reportablePinsInWorkspace:r,isDevDependency:i=!1}=o,{scope:l,name:k,range:d}=n,p=j({scope:l,name:k,range:d}),g=this.isDependencyExplicitlyIncluded({name:k,range:d});if(!D.needsPin(d)&&(g?this.logVerboseInfo(`${s}`,`Include: ${p}`):this.logVerboseWarning(`${s}`,`Skip: ${p}`),!g))return;if(this.onlyPackages&&!this.onlyPackages.includes(p)){this.logVerboseWarning(`${s}`,`Omit: ${p}`);return}let I=d.match(/^(.*)$/),y=this.locatorsByIdent.get(e),m;if(y!==void 0&&y.size>1){let v=Array.from(y).map(u=>{let f=this.project.storedPackages.get(u);if(f===void 0)throw new TypeError(`Can't find package for locator hash '${u}'`);if(c.structUtils.isVirtualLocator(f)){let P=c.structUtils.devirtualizeLocator(f);return this.project.storedPackages.get(P.locatorHash)}return f}).filter(u=>u.version===null?!1:g?!0:I===null?!1:(0,W.satisfies)(u.version,I[1])).sort((u,f)=>g||(0,W.gt)(u.version,f.version)?-1:1);if(v.length>1){let u=v.map((P,C)=>v.slice(C+1).map(O=>[P,O])).flat(),f=0;for(let[P,C]of u)c.structUtils.areLocatorsEqual(P,C)||(f=f+1);f>0&&this.log.reportWarningOnce(0,`Possible duplicate: ${p} has ${v.length} candidates (${f} conflicting pairs) in workspace ${s}`)}m=this.project.storedPackages.get(v[0].locatorHash)}else y.size===1?m=this.project.storedPackages.get(Array.from(y)[0]):this.log.reportWarning(0,`Missing locator: ${p}, in workspace ${s}`);m.version===d?g?this.log.reportInfo(0,`${M("-")} Already pinned: ${p}`):this.logVerboseWarning(`${s}`,`already pinned ${p} to ${m.version}`):(a.set(e,m),r.set(p,m.version),this.logVerboseInfo(`${s}`,`will pin ${p} to ${m.version} in ${s}`))}get pinnableJSON(){let e=(n=new Map)=>Object.fromEntries(Array.from(n.entries(),([o,s])=>s instanceof Map?[o,e(s)]:[o,s]));return e(this.reportablePinsByWorkspaceCwd)}static needsPin(e){return!!c.semverUtils.validRange(e)}},B=D;B.paths=[["pin-deps"]];B.usage=h.Command.Usage({description:"pin-deps [--dry] [--include name:range]",details:"\n        Pin any unpinned dependencies to their currently resolved version.\n        Pass `--dry` for a dry-run. Otherwise, write changes to `package.json`\n        files directly. You will still need to `yarn install` for the changes\n        to take effect.\n        Search all workspaces by default. Pass `--workspace` flag(s) to focus\n        on one or multiple workspace(s).\n        Search all packages with semver range references by default. To include\n        otherwise skipped packages, specify `--include name:range`. To focus\n        only on specific package(s), specify `--only name:range`\n      ",examples:[[`Update package.json in every workspace, to pin all packages with
          semver range to their currently resolved version.`,"$0 pin-deps"],[`Perform a "dry run" \u2013 do not apply any changes to files, but otherwise
          run command as normally.`,"$0 pin-deps --dry"],["Include (do not skip) any packages with reference next:canary","$0 pin-deps --include next:canary"],["Include any package with range `canary` (not a regex, only works for this syntax)","$0 pin-deps --include :canary"],["Include _only_ packages with reference next:canary or material-ui/core:latest","$0 pin-deps --only next:canary --only material-ui/core:latest"],["Include _only_ workspaces by matching one of workspace.name, workspace.cwd, or workspace.relativeCwd","$0 pin-deps --workspace acmeco/design --workspace acmeco/auth"],["Ignore devDependencies (pin only regular dependencies)","$0 pin-deps --ignore-dev"],["Pin only devDependencies in acmeco/design or acmeco/components","$0 pin-deps --only-dev --workspace acmeco/design --workspace acmeco/components"],["Hacky: print a specific package resolution (`yarn why` or `yarn info` is likely better)","$0 pin-deps --dry --workspace @acmeco/design --only next:canary"],["Print verbose logs (including alerady pinned packages)","$0 --verbose"]]});var G={commands:[B]},F=G;return K;})();
return plugin;
}
};
